import { ExceptionOptionType as __ExceptionOptionType } from "@aws-sdk/smithy-client";
import { Readable } from "stream";
import { PollyServiceException as __BaseException } from "./PollyServiceException";
export interface DeleteLexiconInput {
  Name: string | undefined;
}
export interface DeleteLexiconOutput {}
export declare class LexiconNotFoundException extends __BaseException {
  readonly name: "LexiconNotFoundException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<LexiconNotFoundException, __BaseException>
  );
}
export declare class ServiceFailureException extends __BaseException {
  readonly name: "ServiceFailureException";
  readonly $fault: "server";
  constructor(
    opts: __ExceptionOptionType<ServiceFailureException, __BaseException>
  );
}
export declare enum Engine {
  NEURAL = "neural",
  STANDARD = "standard",
}
export declare type LanguageCode =
  | "arb"
  | "ca-ES"
  | "cmn-CN"
  | "cy-GB"
  | "da-DK"
  | "de-AT"
  | "de-DE"
  | "en-AU"
  | "en-GB"
  | "en-GB-WLS"
  | "en-IN"
  | "en-NZ"
  | "en-US"
  | "en-ZA"
  | "es-ES"
  | "es-MX"
  | "es-US"
  | "fr-CA"
  | "fr-FR"
  | "hi-IN"
  | "is-IS"
  | "it-IT"
  | "ja-JP"
  | "ko-KR"
  | "nb-NO"
  | "nl-NL"
  | "pl-PL"
  | "pt-BR"
  | "pt-PT"
  | "ro-RO"
  | "ru-RU"
  | "sv-SE"
  | "tr-TR";
export interface DescribeVoicesInput {
  Engine?: Engine | string;
  LanguageCode?: LanguageCode | string;
  IncludeAdditionalLanguageCodes?: boolean;
  NextToken?: string;
}
export declare type Gender = "Female" | "Male";
export declare type VoiceId =
  | "Aditi"
  | "Amy"
  | "Aria"
  | "Arlet"
  | "Arthur"
  | "Astrid"
  | "Ayanda"
  | "Bianca"
  | "Brian"
  | "Camila"
  | "Carla"
  | "Carmen"
  | "Celine"
  | "Chantal"
  | "Conchita"
  | "Cristiano"
  | "Daniel"
  | "Dora"
  | "Emma"
  | "Enrique"
  | "Ewa"
  | "Filiz"
  | "Gabrielle"
  | "Geraint"
  | "Giorgio"
  | "Gwyneth"
  | "Hannah"
  | "Hans"
  | "Ines"
  | "Ivy"
  | "Jacek"
  | "Jan"
  | "Joanna"
  | "Joey"
  | "Justin"
  | "Kajal"
  | "Karl"
  | "Kendra"
  | "Kevin"
  | "Kimberly"
  | "Lea"
  | "Liam"
  | "Liv"
  | "Lotte"
  | "Lucia"
  | "Lupe"
  | "Mads"
  | "Maja"
  | "Marlene"
  | "Mathieu"
  | "Matthew"
  | "Maxim"
  | "Mia"
  | "Miguel"
  | "Mizuki"
  | "Naja"
  | "Nicole"
  | "Olivia"
  | "Pedro"
  | "Penelope"
  | "Raveena"
  | "Ricardo"
  | "Ruben"
  | "Russell"
  | "Salli"
  | "Seoyeon"
  | "Takumi"
  | "Tatyana"
  | "Vicki"
  | "Vitoria"
  | "Zeina"
  | "Zhiyu";
export interface Voice {
  Gender?: Gender | string;
  Id?: VoiceId | string;
  LanguageCode?: LanguageCode | string;
  LanguageName?: string;
  Name?: string;
  AdditionalLanguageCodes?: (LanguageCode | string)[];
  SupportedEngines?: (Engine | string)[];
}
export interface DescribeVoicesOutput {
  Voices?: Voice[];
  NextToken?: string;
}
export declare class InvalidNextTokenException extends __BaseException {
  readonly name: "InvalidNextTokenException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidNextTokenException, __BaseException>
  );
}
export declare class EngineNotSupportedException extends __BaseException {
  readonly name: "EngineNotSupportedException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<EngineNotSupportedException, __BaseException>
  );
}
export interface GetLexiconInput {
  Name: string | undefined;
}
export interface Lexicon {
  Content?: string;
  Name?: string;
}
export interface LexiconAttributes {
  Alphabet?: string;
  LanguageCode?: LanguageCode | string;
  LastModified?: Date;
  LexiconArn?: string;
  LexemesCount?: number;
  Size?: number;
}
export interface GetLexiconOutput {
  Lexicon?: Lexicon;
  LexiconAttributes?: LexiconAttributes;
}
export interface GetSpeechSynthesisTaskInput {
  TaskId: string | undefined;
}
export declare enum OutputFormat {
  JSON = "json",
  MP3 = "mp3",
  OGG_VORBIS = "ogg_vorbis",
  PCM = "pcm",
}
export declare enum SpeechMarkType {
  SENTENCE = "sentence",
  SSML = "ssml",
  VISEME = "viseme",
  WORD = "word",
}
export declare enum TaskStatus {
  COMPLETED = "completed",
  FAILED = "failed",
  IN_PROGRESS = "inProgress",
  SCHEDULED = "scheduled",
}
export declare enum TextType {
  SSML = "ssml",
  TEXT = "text",
}
export interface SynthesisTask {
  Engine?: Engine | string;
  TaskId?: string;
  TaskStatus?: TaskStatus | string;
  TaskStatusReason?: string;
  OutputUri?: string;
  CreationTime?: Date;
  RequestCharacters?: number;
  SnsTopicArn?: string;
  LexiconNames?: string[];
  OutputFormat?: OutputFormat | string;
  SampleRate?: string;
  SpeechMarkTypes?: (SpeechMarkType | string)[];
  TextType?: TextType | string;
  VoiceId?: VoiceId | string;
  LanguageCode?: LanguageCode | string;
}
export interface GetSpeechSynthesisTaskOutput {
  SynthesisTask?: SynthesisTask;
}
export declare class InvalidTaskIdException extends __BaseException {
  readonly name: "InvalidTaskIdException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidTaskIdException, __BaseException>
  );
}
export declare class SynthesisTaskNotFoundException extends __BaseException {
  readonly name: "SynthesisTaskNotFoundException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<SynthesisTaskNotFoundException, __BaseException>
  );
}
export declare class InvalidLexiconException extends __BaseException {
  readonly name: "InvalidLexiconException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidLexiconException, __BaseException>
  );
}
export declare class InvalidS3BucketException extends __BaseException {
  readonly name: "InvalidS3BucketException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidS3BucketException, __BaseException>
  );
}
export declare class InvalidS3KeyException extends __BaseException {
  readonly name: "InvalidS3KeyException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidS3KeyException, __BaseException>
  );
}
export declare class InvalidSampleRateException extends __BaseException {
  readonly name: "InvalidSampleRateException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidSampleRateException, __BaseException>
  );
}
export declare class InvalidSnsTopicArnException extends __BaseException {
  readonly name: "InvalidSnsTopicArnException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidSnsTopicArnException, __BaseException>
  );
}
export declare class InvalidSsmlException extends __BaseException {
  readonly name: "InvalidSsmlException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidSsmlException, __BaseException>
  );
}
export declare class LanguageNotSupportedException extends __BaseException {
  readonly name: "LanguageNotSupportedException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<LanguageNotSupportedException, __BaseException>
  );
}
export interface LexiconDescription {
  Name?: string;
  Attributes?: LexiconAttributes;
}
export declare class LexiconSizeExceededException extends __BaseException {
  readonly name: "LexiconSizeExceededException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<LexiconSizeExceededException, __BaseException>
  );
}
export interface ListLexiconsInput {
  NextToken?: string;
}
export interface ListLexiconsOutput {
  Lexicons?: LexiconDescription[];
  NextToken?: string;
}
export interface ListSpeechSynthesisTasksInput {
  MaxResults?: number;
  NextToken?: string;
  Status?: TaskStatus | string;
}
export interface ListSpeechSynthesisTasksOutput {
  NextToken?: string;
  SynthesisTasks?: SynthesisTask[];
}
export declare class MarksNotSupportedForFormatException extends __BaseException {
  readonly name: "MarksNotSupportedForFormatException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      MarksNotSupportedForFormatException,
      __BaseException
    >
  );
}
export declare class MaxLexemeLengthExceededException extends __BaseException {
  readonly name: "MaxLexemeLengthExceededException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      MaxLexemeLengthExceededException,
      __BaseException
    >
  );
}
export declare class MaxLexiconsNumberExceededException extends __BaseException {
  readonly name: "MaxLexiconsNumberExceededException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      MaxLexiconsNumberExceededException,
      __BaseException
    >
  );
}
export interface PutLexiconInput {
  Name: string | undefined;
  Content: string | undefined;
}
export interface PutLexiconOutput {}
export declare class UnsupportedPlsAlphabetException extends __BaseException {
  readonly name: "UnsupportedPlsAlphabetException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      UnsupportedPlsAlphabetException,
      __BaseException
    >
  );
}
export declare class UnsupportedPlsLanguageException extends __BaseException {
  readonly name: "UnsupportedPlsLanguageException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      UnsupportedPlsLanguageException,
      __BaseException
    >
  );
}
export declare class SsmlMarksNotSupportedForTextTypeException extends __BaseException {
  readonly name: "SsmlMarksNotSupportedForTextTypeException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      SsmlMarksNotSupportedForTextTypeException,
      __BaseException
    >
  );
}
export interface StartSpeechSynthesisTaskInput {
  Engine?: Engine | string;
  LanguageCode?: LanguageCode | string;
  LexiconNames?: string[];
  OutputFormat: OutputFormat | string | undefined;
  OutputS3BucketName: string | undefined;
  OutputS3KeyPrefix?: string;
  SampleRate?: string;
  SnsTopicArn?: string;
  SpeechMarkTypes?: (SpeechMarkType | string)[];
  Text: string | undefined;
  TextType?: TextType | string;
  VoiceId: VoiceId | string | undefined;
}
export interface StartSpeechSynthesisTaskOutput {
  SynthesisTask?: SynthesisTask;
}
export declare class TextLengthExceededException extends __BaseException {
  readonly name: "TextLengthExceededException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<TextLengthExceededException, __BaseException>
  );
}
export interface SynthesizeSpeechInput {
  Engine?: Engine | string;
  LanguageCode?: LanguageCode | string;
  LexiconNames?: string[];
  OutputFormat: OutputFormat | string | undefined;
  SampleRate?: string;
  SpeechMarkTypes?: (SpeechMarkType | string)[];
  Text: string | undefined;
  TextType?: TextType | string;
  VoiceId: VoiceId | string | undefined;
}
export interface SynthesizeSpeechOutput {
  AudioStream?: Readable | ReadableStream | Blob;
  ContentType?: string;
  RequestCharacters?: number;
}
export declare const DeleteLexiconInputFilterSensitiveLog: (
  obj: DeleteLexiconInput
) => any;
export declare const DeleteLexiconOutputFilterSensitiveLog: (
  obj: DeleteLexiconOutput
) => any;
export declare const DescribeVoicesInputFilterSensitiveLog: (
  obj: DescribeVoicesInput
) => any;
export declare const VoiceFilterSensitiveLog: (obj: Voice) => any;
export declare const DescribeVoicesOutputFilterSensitiveLog: (
  obj: DescribeVoicesOutput
) => any;
export declare const GetLexiconInputFilterSensitiveLog: (
  obj: GetLexiconInput
) => any;
export declare const LexiconFilterSensitiveLog: (obj: Lexicon) => any;
export declare const LexiconAttributesFilterSensitiveLog: (
  obj: LexiconAttributes
) => any;
export declare const GetLexiconOutputFilterSensitiveLog: (
  obj: GetLexiconOutput
) => any;
export declare const GetSpeechSynthesisTaskInputFilterSensitiveLog: (
  obj: GetSpeechSynthesisTaskInput
) => any;
export declare const SynthesisTaskFilterSensitiveLog: (
  obj: SynthesisTask
) => any;
export declare const GetSpeechSynthesisTaskOutputFilterSensitiveLog: (
  obj: GetSpeechSynthesisTaskOutput
) => any;
export declare const LexiconDescriptionFilterSensitiveLog: (
  obj: LexiconDescription
) => any;
export declare const ListLexiconsInputFilterSensitiveLog: (
  obj: ListLexiconsInput
) => any;
export declare const ListLexiconsOutputFilterSensitiveLog: (
  obj: ListLexiconsOutput
) => any;
export declare const ListSpeechSynthesisTasksInputFilterSensitiveLog: (
  obj: ListSpeechSynthesisTasksInput
) => any;
export declare const ListSpeechSynthesisTasksOutputFilterSensitiveLog: (
  obj: ListSpeechSynthesisTasksOutput
) => any;
export declare const PutLexiconInputFilterSensitiveLog: (
  obj: PutLexiconInput
) => any;
export declare const PutLexiconOutputFilterSensitiveLog: (
  obj: PutLexiconOutput
) => any;
export declare const StartSpeechSynthesisTaskInputFilterSensitiveLog: (
  obj: StartSpeechSynthesisTaskInput
) => any;
export declare const StartSpeechSynthesisTaskOutputFilterSensitiveLog: (
  obj: StartSpeechSynthesisTaskOutput
) => any;
export declare const SynthesizeSpeechInputFilterSensitiveLog: (
  obj: SynthesizeSpeechInput
) => any;
export declare const SynthesizeSpeechOutputFilterSensitiveLog: (
  obj: SynthesizeSpeechOutput
) => any;
